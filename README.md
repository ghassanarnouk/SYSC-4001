# [SYSC4001] Operating Systems

Introduction to operating system principles. Processes and threads. CPU scheduling. 
Managing concurrency: mutual exclusion and synchronization, deadlock and starvation. 
Managing memory and input/output. Concurrent programming, including interprocess communication in 
distributed systems.

## Course Objectives

Operating systems exploit the hardware resources of one or more processors to provide a set of services to system users. 
The operating system also manages secondary memory and I/O devices on behalf of its users. 
There is a tremendous range and variety of computer systems for which operating systems are being designed: from embedded devices
(e.g., the on-board computers for the space shuttle or a luxury sedan) and smartphones over PDAs and Laptops to PCs, workstations, and mainframes, to supercomputers. 
The variety is not just in the capacity and speed of machines, but in applications and system support requirements. 
Also, operating system research has been characterized by a rapid rate of change, and there is no indication that this will let up. 
Just think about such topics as the Java Virtual Machine, Android, or iOS.

In spite of this variety and pace of change, certain fundamental concepts apply consistently throughout. The intent of this course is to provide a thorough discussion of the fundamentals of operating system design, and to relate these to contemporary design issues and current directions in the development of operating systems. The objective is to provide you with a solid understanding of the key mechanisms of modern operating systems, the types of design tradeoffs and decisions involved in OS design, and the context within which the operating system functions (hardware, other system programs, application programs, interactive users).

## Learning Outcomes

Students will learn the following:

1. Understand the concepts of (and differences between) processes and threads
2. Write concurrent programs using IPC, semaphores, and other operating system services
3. Identify cases of deadlock, livestock and starvation
4. Know different techniques for Memory management
5. Know different techniques for CPU scheduling, including uniprocessor scheduling, multiprocessor scheduling, and real-time scheduling
6. Explain how I/O devices challenge an Operating System and what general purpose features are provided by an OS to manage the collection of vastly different I/O devices
7. Explore different disk scheduling policies
8. Understand how file systems work and are organized
9. Can conduct comparative studies on different management algorithms for memory, CPU, file systems, I/O